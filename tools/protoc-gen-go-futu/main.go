package main

import (
	"flag"
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"path/filepath"
	"sort"
	"strings"
)

func newFilename(base, fn string) string {
	return filepath.Dir(base) + "/" + fn
}

func newGeneratedFile(plugin *protogen.Plugin, filename string) *protogen.GeneratedFile {
	f := plugin.Files[0]
	fn := filepath.Dir(f.GeneratedFilenamePrefix) + "/" + filename

	g := plugin.NewGeneratedFile(fn, f.GoImportPath)
	g.P(`// Code generated by protoc-gen-go-futu. DO NOT EDIT.`)
	g.P()
	g.P(`package `, f.GoPackageName)
	g.P()

	return g
}

func generateProtoIdAdapt(plugin *protogen.Plugin) error {

	g := newGeneratedFile(plugin, "adapt_protoid.go")

	// sort protoId by value
	ids := []int{}
	for k, _ := range protoid_id2name {
		ids = append(ids, k)
	}
	sort.Ints(ids)

	// gen type
	g.P(`type ProtoId int`)

	// gen protoId const
	g.P(`const (`)
	for _, v := range ids {
		g.P("ProtoId_", protoid_id2name[v], " ProtoId =", v)
	}
	g.P(`)`)

	// gen IsPushId func
	g.P(`func IsPushProtoId(id ProtoId) bool {`)
	g.P(`	switch id {`)
	for _, v := range protoid_push {
		g.P(`case ProtoId_`, protoid_id2name[v], `: return true`)
	}
	g.P(`	}`)
	g.P(`	return false`)
	g.P(`}`)

	return nil
}

func generateEnumAdapt(plugin *protogen.Plugin, enums []*protogen.Enum) error {
	//
	sort.Slice(enums, func(i, j int) bool {
		return enums[i].GoIdent.GoName < enums[j].GoIdent.GoName
	})

	g := newGeneratedFile(plugin, "adapt_enums.go")

	// generate enums
	g.P(`const (`)
	for _, enum := range enums {
		g.P(`// Enum: `, enum.Desc.Name())
		name := enum.GoIdent.GoName
		for _, v := range enum.Values {
			g.P(v.Desc.Name(), " ", name, "=", v.GoIdent.GoName)
		}
		g.P()
	}
	g.P(`)`)

	return nil
}

func generateRequestAdapt(plugin *protogen.Plugin, msgs []*protogen.Message) error {

	g := newGeneratedFile(plugin, "adapt_request.go")

	g.P(`

		import "context"
		import "google.golang.org/protobuf/proto"

		type RequestHandler interface {
			Request(context.Context, ProtoId, proto.Message, Response) (proto.Message, error)
		}

	`)

	for _, msg := range msgs {
		reqName := string(msg.Desc.Name())
		idName := strings.TrimSuffix(reqName, "Request")

		_, idExist := protoid_name2id[idName]

		if !idExist {
			g.P(`/* ProtoId Not Exist: `, idName)
		}

		g.P(fmt.Sprintf(`
			func (m *%s) MakeRequest(ctx context.Context, rh RequestHandler) (*%sResponse, error) {
				req := &%s_Internal{ Payload: m }
				resp_internal := &%sResponse_Internal{}
				if resp, err := rh.Request(ctx, ProtoId_%s, req, resp_internal); err != nil {
					return nil, err
				} else {
					return resp.(*%sResponse), nil
				}
			}
		`, reqName, idName, reqName, idName, idName, idName),
		)

		if !idExist {
			g.P(`*/`)
		}
	}

	return nil
}

func generateResponseAdapt(plugin *protogen.Plugin, msgs []*protogen.Message) error {

	g := newGeneratedFile(plugin, "adapt_response.go")

	g.P(`

		import (
			"errors"
			"google.golang.org/protobuf/proto"
		)

		type Response interface {
			proto.Message
			GetRetType() RetType
			GetRetMsg() string
			GetResponsePayload() proto.Message
		}

		func ResponseError(r Response) error {
			if r.GetRetType() != RetType_Succeed {
				return errors.New(r.GetRetMsg())
			}
			return nil
		}

	`)

	//
	for _, msg := range msgs {
		respName := string(msg.Desc.Name())

		g.P(fmt.Sprintf(`
			func (m *%s_Internal) GetResponsePayload() proto.Message {
				return m.GetPayload()
			}
		`, respName),
		)
	}

	//
	g.P(`func GetPushResponseStruct(id ProtoId) Response {`)
	g.P(`	switch id {`)
	for _, id := range protoid_push {
		name := protoid_id2name[id]
		g.P(
			fmt.Sprintf("case ProtoId_%s: return &%sResponse_Internal{}",
				name, name),
		)
	}
	g.P(`	}`)
	g.P(``)
	g.P(`	return nil`)
	g.P(`}`)

	return nil
}

func collect_msgs(msg *protogen.Message, msgs map[string]*protogen.Message) {
	for _, f := range msg.Fields {
		if f.Desc.Kind() == protoreflect.MessageKind {
			collect_msgs(f.Message, msgs)
		}
	}

	goname := string(msg.GoIdent.GoName)
	msgs[goname] = msg
}

func generateRequestBuilderForMessage(g *protogen.GeneratedFile, msg *protogen.Message) {

	fields := map[string]*protogen.Field{}
	keys := []string{}
	for _, f := range msg.Fields {
		keys = append(keys, f.GoName)
		fields[f.GoName] = f
	}
	sort.Strings(keys)

	msgName := string(msg.GoIdent.GoName)
	for _, fName := range keys {
		f := fields[fName]

		fKind := f.Desc.Kind()
		fIsList := f.Desc.IsList()

		fTypeName := f.Desc.Kind().String()
		switch fKind {
		case protoreflect.MessageKind:
			fTypeName = "*" + f.Message.GoIdent.GoName
		case protoreflect.EnumKind:
			fTypeName = f.Enum.GoIdent.GoName
		case protoreflect.FloatKind:
			fTypeName = "float32"
		case protoreflect.DoubleKind:
			fTypeName = "float64"
		case protoreflect.BytesKind:
			fTypeName = "[]byte"
		}

		if fIsList {
			fTypeName = "..." + fTypeName
		}

		// strip Trd, Qot
		funcName := fName
		if len(funcName) > 3 {
			switch funcName[:3] {
			case "Trd", "Qot":
				funcName = funcName[3:]
			}
		}

		// body
		funcBody := ""
		switch {
		case fIsList:
			fallthrough
		case fKind == protoreflect.MessageKind:
			fallthrough
		case fKind == protoreflect.BytesKind:
			funcBody = fmt.Sprintf(`s.%s = o`, fName)

		case fKind == protoreflect.EnumKind:
			funcBody = fmt.Sprintf(`s.%s = o.Enum()`, fName)
		default:
			funcBody = fmt.Sprintf(`s.%s = &o`, fName)
		}

		g.P(fmt.Sprintf(`
			func (s *%s) With%s(o %s) *%s {
				%s
				return s
			}`, msgName, funcName, fTypeName, msgName, funcBody))
	}
}

func generateRequestBuilder(plugin *protogen.Plugin, msgs []*protogen.Message) error {

	g := newGeneratedFile(plugin, "adapt_req_builder.go")

	all_msgs := map[string]*protogen.Message{}
	for _, msg := range msgs {
		collect_msgs(msg, all_msgs)
	}

	msg_keys := []string{}
	for k, _ := range all_msgs {
		msg_keys = append(msg_keys, k)
	}
	sort.Strings(msg_keys)

	for _, k := range msg_keys {
		g.P(`// `, k)
		msg := all_msgs[k]
		generateRequestBuilderForMessage(g, msg)
	}
	return nil
}

func main() {

	var flags flag.FlagSet

	var (
		enums []*protogen.Enum
		reqs  []*protogen.Message
		resps []*protogen.Message
	)

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(plugin *protogen.Plugin) error {

		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}

			enums = append(enums, f.Enums...)

			for _, msg := range f.Messages {
				name := string(msg.Desc.Name())
				if strings.HasSuffix(name, "Request") {
					reqs = append(reqs, msg)
				} else if strings.HasSuffix(name, "Response") {
					resps = append(resps, msg)
				}
			}
		}

		generateEnumAdapt(plugin, enums)
		generateProtoIdAdapt(plugin)
		generateRequestAdapt(plugin, reqs)
		generateResponseAdapt(plugin, resps)
		generateRequestBuilder(plugin, reqs)

		return nil
	})
}
